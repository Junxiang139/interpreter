(+ 1 2)
(+ 1.0 2.0)
(+ 1 2.0)
(/ 3 4)
(+ 123/345 456/567)
(+ 1.0 123/456)
(- 1.23645 0.23645)
(* 200.2 200.2)
(+ (/ 3 13) (/ 5.0 13))
(+ 2 5 6)
(/ (/ 3 4) (/ 5 6))
(+ (/ 3 4) (/ 1 4))
(= 0 1)
(define a 3)
(define b (+ a 1))
(if (and (> b a) (< b (* a b)))
     b
     a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
(define (expt1 b n)
  (if (= n 0)
      1
      (* b (expt1 b (- n 1)))))
(define (square x) (* x x))
(define (expt2 b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))

(define (even1? n) (= (modulo n 2) 0))
(define (fast-expt1 b n)
  (cond ((= n 0) 1)
        ((even1? n) (square (fast-expt1 b (/ n 2))))
        (else (* b (fast-expt1 b (- n 1))))))

(expt1 2 100)
(expt2 2 100)
(fast-expt1 2 100)
(modulo 100 27)
(define (abs1 x) (if (> x 0) x (- 0 x)))
(abs1 -24.4)
(define (fib n)
 (cond ((= n 0) 0)
       ((= n 1) 1)
       (else (+ (fib (- n 1))
               (fib (- n 2))))))
(fib 5)
(fib 20)
(fib 32)

(define (average a b) (/ (+ a b) 2.0))
(define (sqrt1 x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.0001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
(sqrt1 23)
(define (square x) (* x x))
(define (cube x) (* x x x))
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
(define (integral f a b dx)
  (* (sum f (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
(integral cube 0 1 0.01)
(integral cube 0 1 0.001)
(define (f x y)
  ((lambda (a b)
    (+ (* x (square a))
    (* y b)
    (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
(f 2 2)
(define (sum-cubes a b)
  (define (inc n) (+ n 1))
  (define (cube n) (* n n n))
  (sum cube a inc b))
(sum-cubes 1 10)

(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
(* 8 (pi-sum 1 1000))
(define (v a) (define b 2) (+ a b))
(v 3)
(display 1)
(newline)
(define var1 1)
(let ((var1 2)
               (y (lambda () var1)))
           (y))  ;; 1
(let* ((var1 2)
                (y (lambda () var1)))
           (y))  ;; 2
(letrec ((var1 2)
                  (y (lambda () var1)))
           (y))  ;; 2
(let* ((var1 2)
             (y var1))
           y)  ;; 2
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else (+ (cc amount
                     (except-first-denomination coin-values))
                 (cc (- amount
                      (first-denomination coin-values))
                     coin-values)))))
(define (no-more? coin-values) (null? coin-values))
(define (first-denomination coin-values) (car coin-values))
(define (except-first-denomination coin-values) (cdr coin-values))
(cc 50 us-coins)
(cc 20 uk-coins)
(define (show obj)
  (display obj)
  (newline))

(define (title obj)
  (newline)
  (show obj))

(title "predicate eqv?")
(show (and
       (eqv? 'a 'a)
       (not (eqv? 'a 'b))
       (eqv? 'lowercase 'LOwERcaSE)
       (eqv? '() '())
       (eqv? 10000000000000 10000000000000)
       (not (eqv? (cons 1 2) (cons 1 2)))
       (let ((lst (cons 1 2)))
         (eqv? lst lst))
       (not (eqv? (lambda() 1) (lambda () 2)))
       (not (eqv? #f 'nil))
       (let ((p (lambda (x) x)))
        (eqv? p p)))) ;; #t

(title "predicate eq?")
(define (compare-eq?-eqv? x y) (eq? (eq? x y) (eqv? x y)))
(show (and
       (eq? #t #t)
       (eq? #f #f)
       (compare-eq?-eqv? 'a 'a)
       (compare-eq?-eqv? 'a 'b)
       (compare-eq?-eqv? 'lowercase 'LOwERcaSE)
       (compare-eq?-eqv? '() '())
       (compare-eq?-eqv? (cons 1 2) (cons 1 2))
       (let ((lst (cons 1 2)))
         (compare-eq?-eqv? lst lst))
       (compare-eq?-eqv? (lambda () 1) (lambda () 2))
       (compare-eq?-eqv? #f 'nil)
       (let ((p (lambda (x) x)))
         (compare-eq?-eqv? p p)))) ;; #t

(title "predicate equal?")
(define (compare-equal?-eqv? x y)
  (if (eqv? x y)
      (equal? x y)
      #t))
(show (and
       (eq? #t #t)
       (eq? #f #f)
       (compare-equal?-eqv? 'a 'a)
       (compare-equal?-eqv? 'a 'b)
       (compare-equal?-eqv? 'lowercase 'LOwERcaSE)
       (compare-equal?-eqv? '() '())
       (compare-equal?-eqv? (cons 1 2) (cons 1 2))
       (let ((lst (cons 1 2)))
         (compare-equal?-eqv? lst lst))
       (compare-equal?-eqv? (lambda () 1) (lambda () 2))
       (compare-equal?-eqv? #f 'nil)
       (let ((p (lambda (x) x)))
         (compare-equal?-eqv? p p))
       (equal? 'a 'a)
       (equal? '(a) '(a))
       (equal? '(a (b) c) '(a (b) c))
       (equal? "abc" "abc")
       (equal? 2 2))) ;; #t
(append (list 1 2) (list 3 4) (list 5 6))
(list (list 1 2) (list 3 4) (list 5 6))
(append (list 1) (list 2))
(begin (define x 2) (+ x 1 2 3))
((lambda () (define x 2) (+ x 1 2 3)))
(define (wtf n)
  (if (= n 0)
      (display 0)
      (begin (wtf (- n 1))
             (display n)
             (wtf (- n 1)))))
(wtf 3)
(append (append (list (list 'a 'b)) (list (list 'b 'c)) (list (list 'c 'd))) (list (list 'd 'e)) (append (list (list 'a 'b)) (list (list 'b 'c)) (list (list 'c 'd))))
(define (hanoi src dest mid n)
  (if (= n 0)
      '()
      (append (hanoi src mid dest (- n 1))
              (list (list src dest))
              (hanoi mid dest src (- n 1)))))
(hanoi 'a 'b 'c 3)  ;; ((a b) (a c) (b c) (a b) (c a) (c b) (a b))
(define (hanoi src dest mid n)
  (if (> n 0)
      (append (hanoi src mid dest (- n 1))
              (list (list src dest))
              (hanoi mid dest src (- n 1)))
	  '()))
(hanoi 'a 'b 'c 3)  ;; ((a b) (a c) (b c) (a b) (c a) (c b) (a b))

(define (show obj)
  (display obj)
  (newline))

(define (title obj)
  (newline)
  (show obj))

(title "fibonacci sequence")
(define fib
  (lambda (n)
    (letrec ((calc-fib (lambda (prev now n)
                         (if (= n 0)
                             prev
                             (calc-fib now (+ prev now) (- n 1))))))
      (calc-fib 0 1 n))))

(show (fib 5))  ;; 5
(show (fib 20)) ;; 6765
(show (fib 32))  ;; 2178309, test how good your memory management is
;; (define unused_var (fib 50000)) ;; test this if you have implemented tail call optimization